using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.FormKeys.Fallout4;
using Mutagen.Bethesda.Plugins;
using Noggog;

namespace WastedLoot;

public class Program
{
    private static Lazy<Settings> _settings = null!;
    private static Settings Settings => _settings.Value;
    
    private static readonly HashSet<FormLink<IIngestibleGetter>> AidItems =
    [
        Fallout4.Ingestible.Stimpak,
        Fallout4.Ingestible.RadAway,
        Fallout4.Ingestible.RadX,
        Fallout4.Ingestible.Buffout,
        Fallout4.Ingestible.MedX,
        Fallout4.Ingestible.Mentats,
        Fallout4.Ingestible.Psycho,
        Fallout4.Ingestible.Jet,
        Fallout4.Ingestible.Bloodpack,
        Fallout4.Ingestible.XCell,
        Fallout4.Ingestible.DayTripper,
        Fallout4.Ingestible.DaddyO,
        Fallout4.Ingestible.BerryMentats,
        Fallout4.Ingestible.OrangeMentats,
        Fallout4.Ingestible.JetFuel,
        Fallout4.Ingestible.Buffjet,
        Fallout4.Ingestible.Bufftats,
        Fallout4.Ingestible.Calmex,
        Fallout4.Ingestible.PsychoJet,
        Fallout4.Ingestible.Psychotats,
        Fallout4.Ingestible.Psychobuff,
        Fallout4.Ingestible.Overdrive,
        Fallout4.Ingestible.Fury,
        Fallout4.Ingestible.UltraJet,
        Fallout4.Ingestible.GrapeMentats,
        Fallout4.Ingestible.HC_Antibiotics,
        Fallout4.Ingestible.HC_Herbal_Anodyne,
        Fallout4.Ingestible.HC_Herbal_Antimicrobial,
        Fallout4.Ingestible.HC_Herbal_Stimulant
    ];
    
    private static readonly HashSet<FormKey> PlacedItemsToIgnore =
    [
        Fallout4.ModKey.MakeFormKey(0x0A2CC5) // Switchblade outside V111, for hunters
    ];
    
    private static readonly HashSet<FormKey> CellsToIgnore =
    [
        Fallout4.ModKey.MakeFormKey(0x000FEC) // In Diamond City, where the trash pickup quest spawns items
    ];
    
    private static HashSet<FormKey> _allLootItems = [];
    private static HashSet<FormKey> _allDummyItems = [];
    private static readonly Random Rngesus = new(80085);

    private static int _itemsRemoved;
    private static int _itemsKept;
    private static int _itemsIgnored;
    
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                nickname: "Settings",
                path: "settings.json",
                out _settings)
            .SetTypicalOpen(GameRelease.Fallout4, "WastedLoot.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
    {
        if (Settings.PatchWorldLoot)
        {
            Console.WriteLine($"Populating list of loot items...");
            
            // Filter MISC items
            if (Settings.RemoveMiscItems)
            {
                foreach (var item in state.LoadOrder.PriorityOrder.OnlyEnabled().MiscItem().WinningOverrides())
                {
                    // Filter which misc items HERE
                    if (item.HasKeyword(Fallout4.Keyword.FeaturedItem) || item.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo)) 
                        continue;
                    
                    // TODO: skip any items in the lootItemsUnique [FLST:0017C668] formlist
                    // Fallout4.FormList.lootItemsUnique
                    
                    // Ignore bones because environmental storytelling
                    if (item.EditorID != null && item.EditorID.Contains("Bones", StringComparison.OrdinalIgnoreCase)) 
                        continue;

                    // Don't skip dummy items but add them to a separate list for future use
                    if (item.EditorID != null && item.EditorID.Contains("Dummy", StringComparison.OrdinalIgnoreCase))
                    {
                        _allDummyItems.Add(item.FormKey);
                        // Important: Don't continue!!!
                    }
                    
                    // Anything else to No Respawn but not delete? Add to _allDummyItems and it will be set
            
                    _allLootItems.Add(item.FormKey);
                }
            }

            // Filter Weapon items
            if (Settings.RemoveWeapons)
            {
                foreach (var item in state.LoadOrder.PriorityOrder.OnlyEnabled().Weapon().WinningOverrides())
                {
                    if (item.HasKeyword(Fallout4.Keyword.FeaturedItem) ||
                        item.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo) ||
                        item.HasKeyword(Fallout4.Keyword.AnimsMine)) continue;

                    // There's only one placed in the Castle. I think it's worth keeping
                    if (item.EditorID != null && 
                        item.EditorID.Contains("nukaGrenade", StringComparison.OrdinalIgnoreCase)) continue;

                    _allLootItems.Add(item.FormKey);
                }
            }

            // Filter Ammo items
            if (Settings.RemoveAmmo)
            {
                foreach (var item in state.LoadOrder.PriorityOrder.OnlyEnabled().Ammunition().WinningOverrides())
                {
                    if (item.HasKeyword(Fallout4.Keyword.FeaturedItem) ||
                        item.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo)) continue;

                    _allLootItems.Add(item.FormKey);
                }
            }

            // Filter Armor items
            if (Settings.RemoveArmor)
            {
                foreach (var item in state.LoadOrder.PriorityOrder.OnlyEnabled().Armor().WinningOverrides())
                {
                    if (item.HasKeyword(Fallout4.Keyword.FeaturedItem) ||
                        item.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo)) continue;

                    _allLootItems.Add(item.FormKey);
                }
            }

            // Filter Ingestible items
            if (Settings.RemoveAid)
            {
                foreach (var item in state.LoadOrder.PriorityOrder.Ingestible().WinningOverrides())
                {
                    if (item.HasKeyword(Fallout4.Keyword.FeaturedItem) ||
                        item.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo)) continue;
                    
                    if (!item.HasKeyword(Fallout4.Keyword.ObjectTypeChem) &&
                        !item.HasKeyword(Fallout4.Keyword.ObjectTypeFood) &&
                        !item.HasKeyword(Fallout4.Keyword.ObjectTypeDrink) &&
                        !item.HasKeyword(Fallout4.Keyword.ObjectTypeNukaCola) &&
                        !AidItems.Contains(item)) continue;

                    _allLootItems.Add(item.FormKey);
                }
            }

            Console.WriteLine($"Removing loot from the world...");

            foreach (var placedObjectContext in state.LoadOrder.PriorityOrder.PlacedObject()
                         .WinningContextOverrides(state.LinkCache))
            {
                // Skip any items not in our master list
                if (!_allLootItems.Contains(placedObjectContext.Record.Base.FormKey)) continue;
                
                // It's already marked as No Respawn
                if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw,
                        (int)PlacedObject.ItemMajorFlag.NoRespawn)) continue;
                
                if (placedObjectContext.Record.EncounterZone.FormKey.Equals(Fallout4.EncounterZone.NoResetZone.FormKey))
                    continue;

                // Skip already disabled objects
                if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw,
                        (int)PlacedObject.DefaultMajorFlag.InitiallyDisabled))
                    continue;
                
                // Ignore items that have an owner (store decorations etc.)
                if (placedObjectContext.Record.Ownership is not null)
                {
                    #if DEBUG
                    Console.WriteLine("Object with owner, skipping...");
                    #endif
                    
                    _itemsIgnored++;
                    continue;
                }
                
                // Skip specific placed items by FormKey
                if (PlacedItemsToIgnore.Contains(placedObjectContext.Record.Base.FormKey)) 
                {
                    #if DEBUG
                    Console.WriteLine("Object in Ignore list found, skipping...");
                    #endif
                    
                    _itemsIgnored++;
                    continue;
                }

                if (placedObjectContext.Record.VirtualMachineAdapter is not null &&
                    (placedObjectContext.Record.VirtualMachineAdapter.Scripts.Count > 1 ||
                     (placedObjectContext.Record.VirtualMachineAdapter.Scripts.Count <= 1 &&
                      !placedObjectContext.Record.VirtualMachineAdapter.Scripts[0].Name.Equals("defaultdisablehavokonload"))))
                    continue;

                if (placedObjectContext.TryGetParentContext<IWorldspace, IWorldspaceGetter>(
                        out var worldspaceContext) &&
                    Settings.WorldspacesToIgnore.Contains(
                        worldspaceContext.Record.FormKey.ToLink<IWorldspaceGetter>()))
                {
                    #if DEBUG
                    Console.WriteLine("Ignored Worldspace found, skipping...");
                    #endif
                    
                    _itemsIgnored++;
                    continue;
                }

                if (placedObjectContext.TryGetParentContext<ICell, ICellGetter>(out var cellContext) &&
                    (Settings.CellsToIgnore.Contains(cellContext.Record.FormKey.ToLink<ICellGetter>()) ||
                     CellsToIgnore.Contains(cellContext.Record.FormKey)))
                {
                    #if DEBUG
                    Console.WriteLine("Ignored Cell found, skipping...");
                    #endif
                    
                    _itemsIgnored++;
                    continue;
                }

                // TODO: Separate percentage for each type of item? Would need to loop multiple times but might be worth
                // Roll a d100; if we roll higher than the Global Chance None (60) then DON'T remove the item
                // (40% chance to keep the item in place)
                // OR if it's a persistent object, just mark it as No Respawn
                // Also set all the Dummys that place LL items, mark as No Respawn
                if (Rngesus.Next(1, 100) >= Settings.GlobalLootChanceNone ||
                    Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw, (int)PlacedObject.DefaultMajorFlag.Persistent) ||
                    _allDummyItems.Contains(placedObjectContext.Record.Base.FormKey))
                {
                    _itemsKept++;
                    
                    // Any items left don't respawn
                    var norespawnPlacedObject = placedObjectContext.GetOrAddAsOverride(state.PatchMod);
                    norespawnPlacedObject.MajorRecordFlagsRaw =
                        Enums.SetFlag(norespawnPlacedObject.MajorRecordFlagsRaw,
                            (int)PlacedObject.ItemMajorFlag.NoRespawn, true);
                    
                    // I don't think this is necessary? Vanilla does it though
                    // norespawnPlacedObject.EncounterZone.SetTo(Fallout4.EncounterZone.NoResetZone);

                    continue;
                }
                
                // Skip Persistent objects
                // Instead we are just flagging all persistent objects as No Respawn above
                // if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw, (int)PlacedObject.DefaultMajorFlag.Persistent))
                //     continue;

                _itemsRemoved++;

                var placedObjectSetter = placedObjectContext.GetOrAddAsOverride(state.PatchMod);
                placedObjectSetter.MajorRecordFlagsRaw = Enums.SetFlag(placedObjectSetter.MajorRecordFlagsRaw,
                    (int)PlacedObject.DefaultMajorFlag.InitiallyDisabled, true);
                // placedObjectSetter.Position = new P3Float(placedObjectSetter.Position.X, placedObjectSetter.Position.Y, -30000);
            }

            Console.WriteLine($"|------------------------|");
            Console.WriteLine($"|         Summary         ");
            Console.WriteLine($"|------------------------|");

            // Summary of what happened
            Console.WriteLine(
                $"{(Math.Round((double)_itemsRemoved / (_itemsRemoved + _itemsKept), 2) * 100)}% of loot items removed");

            Console.WriteLine($"Loot Items removed: {_itemsRemoved}");
            Console.WriteLine($"Loot Items kept: {_itemsKept}");
            Console.WriteLine($"Loot Items ignored: {_itemsIgnored}");
        }
        
        foreach (var rec in state.PatchMod.EnumerateMajorRecords())
        {
            rec.IsCompressed = false;
        }
    }
}