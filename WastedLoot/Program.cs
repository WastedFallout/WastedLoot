using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.FormKeys.Fallout4;
using Mutagen.Bethesda.Plugins;
using Noggog;

namespace WastedLoot;

public class Program
{
    private static Lazy<Settings> _settings = null!;
    private static Settings Settings => _settings.Value;
    
    private static HashSet<FormKey> _allLootItems = [];
    private static Random _rng = new(80085);

    private static int _itemsRemoved;
    private static int _itemsKept;
    
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                nickname: "Settings",
                path: "settings.json",
                out _settings)
            .SetTypicalOpen(GameRelease.Fallout4, "WastedLoot.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
    {
        if (Settings.PatchWorldLoot)
        {
            Console.WriteLine($"Populating list of loot items...");

            // Filter Ingestible items
            foreach (var item in state.LoadOrder.PriorityOrder.Ingestible().WinningOverrides())
            {
                // if (!AidItems.Contains(item)) continue;
                
                if (item.Keywords != null &&
                    (item.Keywords.Contains(Fallout4.Keyword.ObjectTypeChem) ||
                     item.Keywords.Contains(Fallout4.Keyword.ObjectTypeFood) ||
                     item.Keywords.Contains(Fallout4.Keyword.ObjectTypeDrink) ||
                     item.Keywords.Contains(Fallout4.Keyword.ObjectTypeNukaCola)))
                {
                    _allLootItems.Add(item.FormKey);
                }
            }

            Console.WriteLine($"Removing loot from the world...");

            foreach (var placedObjectContext in state.LoadOrder.PriorityOrder.PlacedObject()
                         .WinningContextOverrides(state.LinkCache))
            {
                // Skip any items not in our master list
                if (!_allLootItems.Contains(placedObjectContext.Record.Base.FormKey)) continue;
                
                // Skip Persistent objects
                if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw,
                        (int)PlacedObject.DefaultMajorFlag.Persistent))
                    continue;

                // Skip already disabled objects
                if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw,
                        (int)PlacedObject.DefaultMajorFlag.InitiallyDisabled))
                    continue;

                // Roll a d100; if we roll higher than the Global Chance None (60) then DON'T remove the item
                // (40% chance to keep the item in place)
                if (_rng.Next(1, 100) >= Settings.GlobalLootChanceNone)
                {
                    _itemsKept++;

                    // It's already marked as No Respawn
                    if (Enums.HasFlag(placedObjectContext.Record.MajorRecordFlagsRaw,
                            (int)PlacedObject.ItemMajorFlag.NoRespawn)) continue;

                    // Any items left don't respawn
                    var norespawnPlacedObject = placedObjectContext.GetOrAddAsOverride(state.PatchMod);
                    norespawnPlacedObject.MajorRecordFlagsRaw =
                        Enums.SetFlag(norespawnPlacedObject.MajorRecordFlagsRaw,
                            (int)PlacedObject.ItemMajorFlag.NoRespawn, true);

                    continue;
                }
                
                _itemsRemoved++;

                var placedObjectSetter = placedObjectContext.GetOrAddAsOverride(state.PatchMod);
                placedObjectSetter.MajorRecordFlagsRaw = Enums.SetFlag(placedObjectSetter.MajorRecordFlagsRaw,
                    (int)PlacedObject.DefaultMajorFlag.InitiallyDisabled, true);
            }

            // Summary of what happened
            Console.WriteLine(
                $"{(Math.Round((double)_itemsRemoved / (_itemsRemoved + _itemsKept), 2) * 100)}% of loot items removed");

            Console.WriteLine($"Loot Items removed: {_itemsRemoved}");
            Console.WriteLine($"Loot Items kept: {_itemsKept}");
        }
    }
}